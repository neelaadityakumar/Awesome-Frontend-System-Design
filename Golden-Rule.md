# ğ†ğ¨ğ¥ğğğ§ ğ‘ğ®ğ¥ğğ¬ ğ¢ğ§ ğš ğ…ğ«ğ¨ğ§ğ­ğğ§ğ ğ’ğ²ğ¬ğ­ğğ¦ ğƒğğ¬ğ¢ğ ğ§ ğˆğ§ğ­ğğ«ğ¯ğ¢ğğ°

1. If we are dealing with a user-intensive application, it's good to use lazy loading techniques for better performance.
2. To prevent blocking of the UI thread, we should consider using Web Workers. Remember about its drawbacks.
3. For responsive design, consider using a mobile-first approach with media queries.
4. If the system requires a complex UI with a lot of user interaction, consider using a frontend framework like React, Angular, or Vue.
5. If you need to handle and maintain the state of the application efficiently, consider using state management libraries like Redux or Mobx.
6. To make the website accessible, ensure proper use of ARIA attributes and semantic HTML.
7. If the application requires real-time data updates, consider using Websockets or Server-Sent Events.
8. If the system requires seamless navigation between different parts of the application, consider using client-side routing.
9. For optimizing large lists or tables in the UI, consider using techniques like windowing.
10. To deal with form validation and data collection, consider using libraries like Formik or react-hook-form.
11. If the system has a component-based architecture, ensure proper component composition.
12. If the system needs to store data in the client-side, we should consider using Cookies, Local Storage, or IndexedDB based on the use case.
13. To reduce the initial load time of the application, implement code splitting.
14. If the application needs to work offline, implement a service worker and build a Progressive Web App (PWA).
15. For efficient error handling, use a centralized error handling system.
16. When dealing with APIs, consider using GraphQL for efficient data retrieval.
17. If the system requires frequent style changes based on props, consider CSS-in-JS libraries.
18. If the system has multiple similar components, consider using higher-order components or render props for code reusability.
19. If the system needs to be SEO-friendly, implement server-side rendering (SSR) or pre-rendering.
20. For large scale applications, use a monorepo structure for easy package management.
21. When dealing with asynchronous data, consider using Promises or async/await for better code readability and error handling.
22. For handling complex animations, consider using libraries like Framer Motion or React Spring.
23. If the application needs to support multiple themes, consider context API and CSS variables.
24. If the application needs to support internationalization, consider libraries like i18next.
25. To ensure the performance of the application, make sure to use the browser's Performance API.
26. For testing components and business logic, consider using libraries like Jest and React Testing Library.
27. To enforce code style and prevent bugs, consider using linters and formatters like ESLint and Prettier.
28. To ensure your frontend is accessible to all users, you should follow WCAG guidelines and use tools for checking accessibility compliance.
29. For maintaining code quality and enforcing coding standards, use static type checkers like TypeScript and linters such as ESLint.
30. Consider implementing state management libraries like Redux or Context API for predictable state management in complex applications with many components
31. If your application deals with real-time data, consider using WebSockets or libraries such as Socket.IO for real-time, bidirectional communication between the client and the server.
32. For managing side effects in your application, libraries like Redux-Thunk or Redux-Saga can be considered.
33. If your application requires routing, libraries like React-Router can help manage different views for your app.

Originally From : ğŸ‘‰ [daddyTrump](https://leetcode.com/discuss/post/3619937/golden-rules-in-a-frontend-system-design-slc5/)
